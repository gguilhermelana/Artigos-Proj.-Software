O artigo aborda a ideia de modularização como forma de tornar sistemas de software mais compreensíveis, flexíveis e fáceis de manter. Parnas argumenta que o valor da modularização depende fortemente do critério usado para dividir um sistema em módulos e que os critérios mais comuns na época não eram os mais eficazes.
Para ilustrar, o autor apresenta o exemplo de um sistema de geração de índice KWIC (Key Word in Context) e propõe duas formas de modularizá-lo. A primeira, mais tradicional, divide o sistema em etapas do fluxo de execução: entrada, geração de shifts, ordenação, saída e controle. Já a segunda segue um critério diferente, baseado em information hiding (ocultamento de informações): cada módulo fica responsável por esconder uma decisão de projeto passivel a mudanças, como formato de armazenamento, estrutura dos dados ou método de ordenação.
A comparação mostra que a segunda abordagem traz vantagens claras. Quando mudanças ocorrem (por exemplo, alterar o formato de entrada ou o modo de armazenar as linhas), na decomposição tradicional vários módulos precisam ser alterados. Na decomposição orientada a information hiding, apenas o módulo responsável pela decisão afetada precisa ser modificado, preservando a independência dos outros. Isso torna o sistema mais fácil de manter, de evoluir e de compreender em partes isoladas.
Parnas também discute aspectos de implementação, embora a abordagem por information hiding possa parecer menos eficiente, técnicas de compilação e montagem permitem obter performance sem perder a modularidade. Além disso, ele mostra que essa forma de decomposição facilita o reuso entre projetos diferentes, já que os módulos são definidos por responsabilidades conceituais, não por etapas de execução.
